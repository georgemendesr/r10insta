const express = require('express');
const multer = require('multer');
const sharp = require('sharp');
const cors = require('cors');
const path = require('path');
const fs = require('fs-extra');
const https = require('https');
const http = require('http');

// Carregar vari√°veis de ambiente: primeiro da raiz do projeto, depois local (override)
try {
  const rootEnv = path.join(__dirname, '..', '.env');
  const localEnv = path.join(__dirname, '.env');
  if (fs.existsSync(rootEnv)) {
    require('dotenv').config({ path: rootEnv });
    console.log('üì¶ .env (raiz) carregado');
  }
  if (fs.existsSync(localEnv)) {
    require('dotenv').config({ path: localEnv, override: true });
    console.log('üì¶ .env (instagram-publisher) carregado, sobrescrevendo o da raiz');
  }
  // Prote√ß√£o: nunca herdar PORT do .env da raiz
  if (process.env.PORT && process.cwd().toLowerCase().includes('instagram-publisher')) {
    // Se a PORT veio do .env de cima (ex.: 8080), ignore e deixe a leitura abaixo usar padr√£o 9000 ou .env local
    if (process.env.PORT === '8080') {
      delete process.env.PORT;
    }
  }
} catch (e) {
  console.log('‚ö†Ô∏è dotenv n√£o carregado (opcional)');
}

const app = express();
// Porta padr√£o do instagram-publisher √© 9000; .env local pode sobrescrever
const PORT = parseInt((process.env.PORT && process.env.PORT !== '8080') ? process.env.PORT : '9000', 10);

// Carregar logo R10 POST (se existir) para uso no topo da UI
let R10_LOGO_DATAURL = null;
try {
  const logoR10PostPath = path.join(__dirname, 'r10post.png');
  if (fs.existsSync(logoR10PostPath)) {
    const buf = fs.readFileSync(logoR10PostPath);
    R10_LOGO_DATAURL = 'data:image/png;base64,' + buf.toString('base64');
    console.log('üñºÔ∏è Logo R10 POST carregada para a interface');
  } else {
    console.log('‚ÑπÔ∏è r10post.png n√£o encontrado; usando fallback padr√£o');
  }
} catch (e) {
  console.log('‚ö†Ô∏è N√£o foi poss√≠vel carregar r10post.png:', e.message);
}

// Middlewares essenciais
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Static para servir a pasta public e, em especial, /uploads (necess√°rio para image_url)
app.use(express.static(path.join(__dirname, 'public')));
app.use('/uploads', express.static(path.join(__dirname, 'public', 'uploads')));
// Rota direta para servir a nova logo, caso referenciada por URL
app.get('/r10post.png', (req, res) => {
  const p = path.join(__dirname, 'r10post.png');
  if (fs.existsSync(p)) return res.sendFile(p);
  return res.status(404).send('logo not found');
});

// Multer storage (salva uploads tempor√°rios em uploads/tmp)
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const dest = path.join(__dirname, 'uploads', 'tmp');
    fs.ensureDir(dest).then(() => cb(null, dest)).catch(err => cb(err));
  },
  filename: (req, file, cb) => {
    const unique = Date.now() + '-' + Math.round(Math.random() * 1e9);
    cb(null, unique + path.extname(file.originalname || ''));
  }
});
const upload = multer({ storage, limits: { fileSize: 15 * 1024 * 1024 } });

// Pequeno helper fetch-like para HTTP/HTTPS
function makeHttpsRequest(inputUrl, options = {}) {
  const { method = 'GET', headers = {}, body } = options;
  return new Promise((resolve) => {
    try {
      const u = new URL(inputUrl);
      const isHttps = u.protocol === 'https:';
      const mod = isHttps ? https : http;
      const reqOptions = {
        method,
        headers,
        hostname: u.hostname,
        port: u.port || (isHttps ? 443 : 80),
        path: u.pathname + (u.search || '')
      };
      const req = mod.request(reqOptions, (res) => {
        const chunks = [];
        res.on('data', (d) => chunks.push(d));
        res.on('end', () => {
          const buffer = Buffer.concat(chunks);
          const text = buffer.toString('utf8');
          const response = {
            ok: res.statusCode >= 200 && res.statusCode < 300,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            text: async () => text,
            json: async () => { try { return JSON.parse(text); } catch { return {}; } },
            buffer: async () => buffer
          };
          resolve(response);
        });
      });
      req.on('error', (err) => {
        resolve({
          ok: false,
          status: 0,
          statusText: err.message,
          headers: {},
          text: async () => '',
          json: async () => ({ error: err.message }),
          buffer: async () => Buffer.alloc(0)
        });
      });
      if (body) {
        if (typeof body === 'string' || Buffer.isBuffer(body)) {
          req.write(body);
        } else {
          const str = JSON.stringify(body);
          req.write(str);
        }
      }
      req.end();
    } catch (err) {
      resolve({
        ok: false,
        status: 0,
        statusText: err.message,
        headers: {},
        text: async () => '',
        json: async () => ({ error: err.message }),
        buffer: async () => Buffer.alloc(0)
      });
    }
  });
}

// Extrator simples de dados de uma p√°gina (og:title/description/image)
async function extractDataFromUrl(pageUrl) {
  console.log('üîç Extraindo dados da URL:', pageUrl);
  
  try {
    const resp = await makeHttpsRequest(pageUrl, { method: 'GET', headers: { 'User-Agent': 'Mozilla/5.0 R10Publisher' } });
    
    console.log('üìä Status da requisi√ß√£o:', resp.status);
    
    if (!resp.ok) {
      console.error('‚ùå Falha na requisi√ß√£o HTTP:', resp.status, resp.statusText);
      throw new Error(`Falha ao carregar URL (status ${resp.status})`);
    }
    
    const html = await resp.text();
    console.log('üìÑ HTML recebido com', html.length, 'caracteres');

    function getMeta(content, attr, name) {
      const rx = new RegExp(`<meta[^>]+${attr}=["']${name}["'][^>]*content=["']([^"']+)["'][^>]*>`, 'i');
      const m = content.match(rx);
      return m ? m[1] : '';
    }
    function getTag(content, tag) {
      const rx = new RegExp(`<${tag}[^>]*>([^<]+)</${tag}>`, 'i');
      const m = content.match(rx);
      return m ? m[1] : '';
    }
    function absoluteUrl(href) {
      try { return new URL(href, pageUrl).href; } catch { return href; }
    }

    let title = getMeta(html, 'property', 'og:title') || getMeta(html, 'name', 'title') || getTag(html, 'title');
    const description = getMeta(html, 'property', 'og:description') || getMeta(html, 'name', 'description') || '';
    let imageUrl = getMeta(html, 'property', 'og:image') || getMeta(html, 'name', 'image') || '';
    if (imageUrl) imageUrl = absoluteUrl(imageUrl);

    // Fallback rudimentar para h1
    if (!title) {
      const h1 = html.match(/<h1[^>]*>([\s\S]*?)<\/h1>/i);
      if (h1) title = h1[1].replace(/<[^>]+>/g, '').trim();
    }

    const result = {
      title: (title || '').replace(/\s+/g, ' ').trim(),
      description: (description || '').trim(),
      imageUrl: imageUrl || '',
      originalUrl: pageUrl
    };
    
    console.log('üìã Dados extra√≠dos:', {
      title: result.title,
      description: result.description.substring(0, 100) + '...',
      imageUrl: result.imageUrl,
      originalUrl: result.originalUrl
    });
    
    return result;
    
  } catch (error) {
    console.error('‚ùå Erro na extra√ß√£o de dados:', error.message);
    console.error('üìç Stack trace:', error.stack);
    throw error;
  }
}

// Carregar fontes na inicializa√ß√£o do servidor - COM FALLBACK ROBUSTO
let EMBEDDED_FONTS_CSS = '';

try {
  const fontsDir = path.join(__dirname, 'fonts');
  console.log(`üîç Procurando fontes em: ${fontsDir}`);
  
  // Verificar se arquivos existem antes de tentar carregar
  const regularPath = path.join(fontsDir, 'Poppins-Regular.ttf');
  const semiboldPath = path.join(fontsDir, 'Poppins-SemiBold.ttf');
  const extraboldPath = path.join(fontsDir, 'Poppins-ExtraBold.ttf');
  
  if (fs.existsSync(regularPath) && fs.existsSync(semiboldPath) && fs.existsSync(extraboldPath)) {
    const regularFont = fs.readFileSync(regularPath);
    const semiboldFont = fs.readFileSync(semiboldPath);
    const extraboldFont = fs.readFileSync(extraboldPath);
    
    const regularBase64 = regularFont.toString('base64');
    const semiboldBase64 = semiboldFont.toString('base64');
    const extraboldBase64 = extraboldFont.toString('base64');
    
    EMBEDDED_FONTS_CSS = `
      <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap');
        @font-face {
          font-family: 'Poppins';
          src: url('data:font/ttf;base64,${regularBase64}') format('truetype'),
               url('/fonts/Poppins-Regular.ttf') format('truetype');
          font-weight: 400;
          font-style: normal;
          font-display: swap;
        }
        @font-face {
          font-family: 'Poppins';
          src: url('data:font/ttf;base64,${semiboldBase64}') format('truetype'),
               url('/fonts/Poppins-SemiBold.ttf') format('truetype');
          font-weight: 600;
          font-style: normal;
          font-display: swap;
        }
        @font-face {
          font-family: 'Poppins';
          src: url('data:font/ttf;base64,${extraboldBase64}') format('truetype'),
               url('/fonts/Poppins-ExtraBold.ttf') format('truetype');
          font-weight: 800;
          font-style: normal;
          font-display: swap;
        }
      </style>
    `;
    
    console.log('‚úÖ Fontes Poppins carregadas com sucesso e embarcadas em Base64');
    console.log(`üìè Tamanhos: Regular=${regularBase64.length} chars, SemiBold=${semiboldBase64.length} chars, ExtraBold=${extraboldBase64.length} chars`);
  } else {
    throw new Error('Arquivos de fonte n√£o encontrados');
  }
} catch (error) {
  console.error('‚ùå ERRO ao carregar fontes Poppins:', error.message);
  console.log('üîÑ Usando Google Fonts como fallback');
  EMBEDDED_FONTS_CSS = `
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap');
    </style>
  `;
}

const INSTAGRAM_CONFIG = {
  BUSINESS_ID: process.env.IG_BUSINESS_ID || '17841401907016879',
  ACCESS_TOKEN: process.env.IG_ACCESS_TOKEN || '',
  GRAPH_API_URL: 'https://graph.facebook.com/v19.0',
  PUBLIC_BASE_URL: process.env.PUBLIC_BASE_URL || '' // URL p√∫blica onde a Meta consegue baixar as imagens
};

const GROQ_CONFIG = {
  API_KEY: process.env.GROQ_API_KEY || '',
  MODEL: process.env.GROQ_MODEL || 'llama3-8b-8192',
  API_URL: 'https://api.groq.com/openai/v1/chat/completions'
};

// Diret√≥rio persistente para armazenar a publi (sobrevive a redeploys)
// Em produ√ß√£o (Render), defina PERSIST_DIR para um disco persistente, ex.: "/data/instagram-publisher"
const PERSIST_DIR = process.env.PERSIST_DIR || path.join(__dirname, 'uploads');

// === Publicidade: gera√ß√£o padr√£o e obten√ß√£o persistente ===
async function generateDefaultPublicityCard() {
  // Cria um card 1080x1350 com fundo escuro e logotipo R10 centralizado + r√≥tulo PUBLICIDADE
  const width = 1080;
  const height = 1350;
  const background = { r: 12, g: 12, b: 12, alpha: 1 }; // fundo #0c0c0c

  // Base s√≥lida
  const base = await sharp({
    create: { width, height, channels: 4, background }
  }).png().toBuffer();

  // Carregar logo
  const logoPath = path.join(__dirname, 'logo-r10-piaui.png');
  let logoBuffer = null;
  try {
    logoBuffer = await fs.readFile(logoPath);
  } catch (e) {
    console.warn('‚ö†Ô∏è Logo n√£o encontrado, continuar√° sem logo:', logoPath);
  }

  // SVG com textos
  const svg = Buffer.from(`
    <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="#111"/>
          <stop offset="100%" stop-color="#222"/>
        </linearGradient>
      </defs>
      <rect x="0" y="0" width="${width}" height="${height}" fill="url(#g)"/>
      <text x="540" y="210" text-anchor="middle" fill="#ffffff" font-family="Poppins, Arial" font-size="54" font-weight="800">PUBLICIDADE</text>
      <text x="540" y="1240" text-anchor="middle" fill="#ffffff" font-family="Poppins, Arial" font-size="34" font-weight="600">R10 PIAU√ç ‚Äî D√° gosto de ver!</text>
    </svg>
  `);

  const composites = [{ input: svg, top: 0, left: 0 }];

  // Se logo existir, redimensiona e centraliza
  if (logoBuffer) {
    const resizedLogo = await sharp(logoBuffer).resize({ width: 700, withoutEnlargement: true }).toBuffer();
    // Posi√ß√£o aproximada central
    const logoTop = Math.round(height / 2) - 220;
    const logoLeft = Math.round((width - 700) / 2);
    composites.push({ input: resizedLogo, top: logoTop, left: logoLeft });
  }

  const buffer = await sharp(base)
    .composite(composites)
    .jpeg({ quality: 92 })
    .toBuffer();

  return buffer;
}

async function getOrCreatePublicityBuffer() {
  await fs.ensureDir(PERSIST_DIR);
  const publicityPath = path.join(PERSIST_DIR, 'publicity-card.jpg');
  if (fs.existsSync(publicityPath)) {
    return fs.readFile(publicityPath);
  }
  // gerar padr√£o e persistir
  const buf = await generateDefaultPublicityCard();
  await fs.writeFile(publicityPath, buf);
  return buf;
}

// Fun√ß√£o para condensar e finalizar t√≠tulo SEM retic√™ncias
// Fun√ß√£o para otimizar t√≠tulo com Groq (sempre tenta IA, mesmo para t√≠tulos curtos)
async function optimizeTitle(title, contextDescription) {
  try {
    console.log(`ü§ñ Otimizando t√≠tulo: "${title}" (${title.length} caracteres)`);
    
    const response = await makeHttpsRequest(GROQ_CONFIG.API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${GROQ_CONFIG.API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: GROQ_CONFIG.MODEL,
        messages: [
          {
            role: 'system',
            content: `Voc√™ √© editor de manchetes jornal√≠sticas para Instagram. Produza t√≠tulos curtos (at√© 70 caracteres), completos e informativos.
Regras inegoci√°veis:
- Manchete deve ter sujeito + verbo de a√ß√£o + complemento (predicado). N√£o retorne apenas nomes ou sujeito solto.
- N√£o use retic√™ncias. N√£o quebre palavras. Gram√°tica perfeita e natural.
- N√£o termine em verbo auxiliar ou preposi√ß√£o ("√©", "foi", "de", "da", "no", "na").
- Evite terminar apenas em partic√≠pio ("nomeado", "anunciado", "confirmado"). Se ocorrer, COMPLETE o cargo/a√ß√£o.
- Se o cargo espec√≠fico n√£o estiver claro, use forma gen√©rica, mas completa: "assume cargo" ou "√© nomeado para cargo".
- Op√ß√£o de lead geogr√°fico √© v√°lida quando fizer sentido: "Piripiri:" ou "Teresina:".
Exemplos bons: "Prefeitura de Teresina anuncia nova obra"; "Jos√© Am√¢ncio Neto √© nomeado coordenador"; "Piripiri: secret√°ria assume pasta da Sa√∫de".
Exemplos ruins (N√ÉO FAZER): "Jos√© Am√¢ncio Neto"; "Governador do Piau√≠"; "Prefeitura anuncia no...".`
          },
          {
            role: 'user',
            content: `Reescreva para uma manchete enxuta e COMPLETA.

T√çTULO ORIGINAL: "${title}"
${contextDescription ? `\nCONTEXTO (descri√ß√£o da mat√©ria): ${contextDescription}` : ''}

INSTRU√á√ïES OBRIGAT√ìRIAS:
- M√°ximo 70 caracteres (essencial!)
- Preservar TODAS as informa√ß√µes importantes
- Linguagem clara e direta
- NUNCA cortar palavras no meio (proibido "co...", "no...", etc)
- Manter nomes pr√≥prios completos sempre
- Se necess√°rio, reformular completamente em vez de apenas cortar
- Gram√°tica perfeita e natural
 - PROIBIDO usar retic√™ncias "..."
 - O t√≠tulo deve ser uma frase/manchete COMPLETA (com conclus√£o)
 - NUNCA terminar em verbo auxiliar ou preposi√ß√£o (ex.: "√©", "foi", "de", "da", "no", "na")
 - Evite terminar com partic√≠pios sem complemento (ex.: "nomeado", "anunciado", "confirmado"). Se aparecerem, complete o cargo/a√ß√£o.

EXEMPLOS ESPEC√çFICOS DO QUE FAZER:
‚ùå P√âSSIMO: "Advogado Piripiriense Jos√© Am√¢ncio Neto √© nomeado co..."
‚úÖ EXCELENTE: "Jos√© Am√¢ncio Neto √© nomeado coordenador"

‚ùå P√âSSIMO: "Prefeitura Municipal de Teresina anuncia no..."
‚úÖ EXCELENTE: "Prefeitura de Teresina anuncia nova obra"

‚ùå P√âSSIMO: "Governador do Estado do Piau√≠ participa de ev..."
‚úÖ EXCELENTE: "Governador participa de evento importante"

Responda APENAS com o t√≠tulo reformulado, sem aspas ou explica√ß√µes. O resultado deve caber sozinho e ter sentido completo.`
          }
        ],
        max_tokens: 100,
        temperature: 0.1
      })
    });

    console.log(`üì° Status da resposta Groq: ${response.status}`);
    
    if (response.ok) {
      const data = await response.json();
      console.log(`üìù Resposta Groq completa:`, JSON.stringify(data, null, 2));
      
      const optimizedTitle = data.choices[0]?.message?.content?.trim();
      if (optimizedTitle && optimizedTitle.length > 0) {
        const cleanTitle = optimizedTitle.replace(/^['"]|['"]$/g, '');
        console.log(`‚úÖ T√≠tulo otimizado: "${cleanTitle}" (${cleanTitle.length} caracteres)`);
        // Normalizar para evitar retic√™ncias e final incompleto + corrigir termina√ß√µes com "nomeado"
        let finalized = finalizeHeadline(cleanTitle, 70);
        finalized = fixNominationEndings(finalized);
        return finalized;
      } else {
        console.log('‚ùå Resposta da Groq vazia ou inv√°lida');
      }
    } else {
      const errorData = await response.json();
      console.error('‚ùå Erro na API Groq:', errorData);
    }
  } catch (error) {
    console.error('‚ùå Erro ao otimizar t√≠tulo:', error.message);
    console.error('‚ùå Stack:', error.stack);
  }
  
  // Fallback: condensar sem retic√™ncias (ainda garantindo final completo)
  console.log(`üîÑ Aplicando fallback - condensa√ß√£o do t√≠tulo original sem retic√™ncias`);
  let finalized = finalizeHeadline(title, 70);
  finalized = fixNominationEndings(finalized);
  console.log(`üîÑ Fallback - t√≠tulo final: "${finalized}"`);
  return finalized;
}

function finalizeHeadline(text, maxLength) {
  console.log(`üìè Finalizando t√≠tulo: "${text}" (${text.length} chars) para m√°ximo ${maxLength}, sem retic√™ncias`);
  if (!text) return text;

  // 1) Normaliza√ß√µes b√°sicas
  let t = text
    .replace(/\u2026|\.\.\./g, '') // remove retic√™ncias
    .replace(/\s+/g, ' ')
    .trim();

  // 2) Cortar em separadores de subt√≠tulo
  const splitters = [' ‚Äî ', ' - ', ' ‚Äì ', ': '];
  for (const s of splitters) {
    if (t.includes(s)) {
      const [head] = t.split(s);
      if (head.length >= maxLength * 0.6) {
        t = head.trim();
        break;
      }
    }
  }

  // 3) Se ainda maior que o limite, remover termos n√£o essenciais
  const removalRounds = [
    /\b(para|por|com|sobre|entre|ap√≥s|antes|durante)\b/gi,
    /\b(de|da|do|das|dos|no|na|nos|nas)\b/gi,
    /\b(√©|foi|ser√°|est√°|est√£o|foram|seriam|seriam|ser√°|seriam)\b/gi
  ];
  for (const rx of removalRounds) {
    if (t.length <= maxLength) break;
    t = t.replace(rx, '').replace(/\s+/g, ' ').trim();
  }

  // 4) Se ainda maior, cortar por palavras at√© caber, SEM '...'
  if (t.length > maxLength) {
    const words = t.split(' ');
    let acc = '';
    for (const w of words) {
      const next = acc ? acc + ' ' + w : w;
      if (next.length <= maxLength) acc = next; else break;
    }
    t = acc.trim();
  }

  // 5) Evitar finais incompletos (preposi√ß√µes/verbos auxiliares)
  const badEndings = new Set(['de','da','do','das','dos','no','na','nos','nas','em','por','para','com','√©','foi','ser√°','est√°','s√£o','foram','nomeado','nomeada','anunciado','anunciada','confirmado','confirmada']);
  let tokens = t.split(' ');
  while (tokens.length > 1 && badEndings.has(tokens[tokens.length - 1].toLowerCase())) {
    tokens.pop();
  }
  t = tokens.join(' ').trim();

  // 6) Casos espec√≠ficos
  // Evitar terminar com "√© nomeado" -> normalizar para n√£o ficar solto
  t = t.replace(/\s+√© nomead[oa]$/i, ' nomeado');
  // Se ainda terminar exatamente em "nomeado/nomeada", retire para n√£o ficar truncado (ser√° tratado por fixNominationEndings)
  if (/\bnomead[oa]$/i.test(t)) {
    t = t.replace(/\s*nomead[oa]$/i, '').trim();
  }

  return t;
}

// Corre√ß√£o local para manchetes que terminam em "nomeado/nomeada" sem complemento
function fixNominationEndings(text) {
  if (!text) return text;
  // Se contiver "nomeado/a" mas sem complemento (no final), mude para uma forma completa e curta
  if (/\bnomead[oa]$/i.test(text)) {
    return text.replace(/\bnomead[oa]$/i, 'assume cargo').trim();
  }
  // Evitar "√© nomeado" no final sem complemento
  if (/\b√© nomead[oa]$/i.test(text)) {
    return text.replace(/\b√© nomead[oa]$/i, 'assume cargo').trim();
  }
  return text;
}

// Fun√ß√£o para gerar chap√©u com Groq AI (palavra complementar)
async function generateChapeu(title) {
  try {
    console.log(`üè∑Ô∏è Gerando chap√©u para: "${title}"`);
    
    const response = await makeHttpsRequest(GROQ_CONFIG.API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${GROQ_CONFIG.API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: GROQ_CONFIG.MODEL,
        messages: [{
          role: 'user',
          content: `Voc√™ √© especialista em comunica√ß√£o jornal√≠stica. Escolha APENAS UMA palavra (chap√©u) da lista a seguir que melhor complemente a manchete.

T√çTULO: "${title}"

LISTA (ESCOLHA UMA): DESTAQUE, URGENTE, IMPORTANTE, EXCLUSIVO, ATEN√á√ÉO, AGORA, OFICIAL, CONFIRMADO, NOVIDADE, √öLTIMA HORA

REGRAS:
- N√ÉO repetir palavra que j√° esteja no t√≠tulo
- UMA palavra, MAI√öSCULAS, at√© 12 caracteres
- Responda APENAS com a palavra, sem aspas`
        }],
        max_tokens: 8,
        temperature: 0.1
      })
    });

    console.log(`üì° Status da resposta Groq (chap√©u): ${response.status}`);
    
    if (response.ok) {
      const data = await response.json();
      console.log(`üìù Resposta Groq chap√©u:`, JSON.stringify(data, null, 2));
      
  const ch = data.choices[0]?.message?.content?.trim().toUpperCase();
      if (ch && ch.length > 0 && ch.length <= 12) {
        const cleanChapeu = ch.replace(/^['"]|['"]$/g, '');
        const allowed = new Set(['DESTAQUE','URGENTE','IMPORTANTE','EXCLUSIVO','ATEN√á√ÉO','AGORA','OFICIAL','CONFIRMADO','NOVIDADE','√öLTIMA HORA','ULTIMA HORA']);
        if (allowed.has(cleanChapeu)) {
          console.log(`‚úÖ Chap√©u gerado: "${cleanChapeu}"`);
          return cleanChapeu.toUpperCase();
        } else {
          console.log('‚ö†Ô∏è Chap√©u fora da lista permitida, aplicando fallback');
        }
      } else {
        console.log('‚ùå Chap√©u inv√°lido ou muito longo');
      }
    } else {
      const errorData = await response.json();
      console.error('‚ùå Erro na API Groq (chap√©u):', errorData);
    }
  } catch (error) {
    console.error('‚ùå Erro ao gerar chap√©u:', error.message);
    console.error('‚ùå Stack:', error.stack);
  }
  
  // Fallback: palavras complementares gen√©ricas
  const fallbacks = ['DESTAQUE', 'NOT√çCIA', 'IMPORTANTE', 'AGORA', 'NOVO', 'URGENTE', 'ATEN√á√ÉO'];
  const selectedFallback = fallbacks[Math.floor(Math.random() * fallbacks.length)];
  console.log(`üîÑ Fallback chap√©u: "${selectedFallback}"`);
  return selectedFallback.toUpperCase();
  return selectedFallback.toUpperCase();
}

// Fun√ß√£o para gerar legenda com Groq (sem categoria)
async function generateCaption(title, chapeu) {
  try {
    console.log(`ü§ñ Gerando legenda para: "${title}" (chap√©u: ${chapeu})`);
    
    const response = await makeHttpsRequest(GROQ_CONFIG.API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${GROQ_CONFIG.API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: GROQ_CONFIG.MODEL,
        messages: [{
          role: 'user',
          content: `Voc√™ √© especialista em social media jornal√≠stica. Crie uma legenda profissional para Instagram:

T√çTULO: "${title}"
CHAP√âU: "${chapeu}"

INSTRU√á√ïES ESPEC√çFICAS:
1. Use o t√≠tulo COMPLETO (n√£o corte nem resuma)
2. Adicione uma linha explicativa curta sobre a not√≠cia
3. Inclua chamada para a√ß√£o "üìç Leia a mat√©ria completa em www.r10piaui.com"
4. Termine com "üî¥ R10 Piau√≠ ‚Äì D√° gosto de ver!"
5. Adicione hashtags: #R10Piau√≠ #Not√≠cias #Piau√≠

ESTRUTURA EXATA:
[T√çTULO COMPLETO]

[Breve explica√ß√£o da not√≠cia]

üìç Leia a mat√©ria completa em www.r10piaui.com

üî¥ R10 Piau√≠ ‚Äì D√° gosto de ver!

#R10Piau√≠ #Not√≠cias #Piau√≠

REGRAS:
- N√ÉO mencione categoria/editoria
- Use linguagem profissional
- Seja objetivo e claro

Legenda:`
        }],
        max_tokens: 200,
        temperature: 0.2
      })
    });

    console.log(`üì° Status da resposta Groq (legenda): ${response.status}`);
    
    if (response.ok) {
      const data = await response.json();
      console.log(`üìù Resposta Groq legenda:`, JSON.stringify(data, null, 2));
      
      let caption = data.choices[0]?.message?.content?.trim();
      if (caption && caption.length > 0) {
        // Normalizar: remover retic√™ncias, linhas extras, e assegurar 1¬™ linha = t√≠tulo
        caption = caption.replace(/[\u2026]|\.\.\./g, '').replace(/\r/g, '');
        const parts = caption.split('\n').map(s => s.trim()).filter(Boolean);
        if (parts.length > 0) parts[0] = title;
        caption = parts.join('\n\n');
        console.log('‚úÖ Legenda gerada com sucesso (normalizada)');
        return caption;
      } else {
        console.log('‚ùå Legenda vazia ou inv√°lida');
      }
    } else {
      const errorData = await response.json();
      console.error('‚ùå Erro na API Groq (legenda):', errorData);
    }
  } catch (error) {
    console.error('‚ùå Erro ao gerar legenda:', error.message);
    console.error('‚ùå Stack:', error.stack);
  }
  
  // Fallback: legenda simples com t√≠tulo completo decodificado
  // Decodificar entidades HTML no t√≠tulo
  function decodeHtmlEntitiesFallback(text) {
    const entities = {
      '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&apos;': '\'', '&nbsp;': ' ',
      '&aacute;': '√°', '&Aacute;': '√Å', '&agrave;': '√†', '&Agrave;': '√Ä',
      '&acirc;': '√¢', '&Acirc;': '√Ç', '&atilde;': '√£', '&Atilde;': '√É',
      '&auml;': '√§', '&Auml;': '√Ñ', '&eacute;': '√©', '&Eacute;': '√â',
      '&egrave;': '√®', '&Egrave;': '√à', '&ecirc;': '√™', '&Ecirc;': '√ä',
      '&iacute;': '√≠', '&Iacute;': '√ç', '&igrave;': '√¨', '&Igrave;': '√å',
      '&icirc;': '√Æ', '&Icirc;': '√é', '&oacute;': '√≥', '&Oacute;': '√ì',
      '&ograve;': '√≤', '&Ograve;': '√í', '&ocirc;': '√¥', '&Ocirc;': '√î',
      '&otilde;': '√µ', '&Otilde;': '√ï', '&uacute;': '√∫', '&Uacute;': '√ö',
      '&ugrave;': '√π', '&Ugrave;': '√ô', '&ucirc;': '√ª', '&Ucirc;': '√õ',
      '&ccedil;': '√ß', '&Ccedil;': '√á'
    };
    return text.replace(/&[a-zA-Z]+;/g, (entity) => entities[entity] || entity);
  }
  
  const titleDecodificado = decodeHtmlEntitiesFallback(title);
  const fallbackCaption = `${titleDecodificado}

Confira todos os detalhes da not√≠cia.

üìç Leia a mat√©ria completa em www.r10piaui.com

üî¥ R10 Piau√≠ ‚Äì D√° gosto de ver!

#R10Piau√≠ #Not√≠cias #Piau√≠`;
  
  console.log(`üîÑ Usando fallback para legenda`);
  return fallbackCaption;
}

// Fun√ß√£o para gerar card com Sharp - EXATAMENTE IGUAL AO SISTEMA PRINCIPAL
async function generateInstagramCard(data) {
  const { title, imagePath, categoria, chapeu, destaquePersonalizado, type = 'card' } = data;
  
  console.log('üé® Gerando card...');
  
  // Usar chap√©u fornecido como par√¢metro ou gerar automaticamente se n√£o fornecido
  const chapeuFinal = chapeu || await generateChapeu(title);
  // Sempre renderizar o chap√©u em CAIXA ALTA no card
  const chapeuUpper = (chapeuFinal || '').toString().trim().toUpperCase();
  console.log(`üè∑Ô∏è Usando chap√©u: "${chapeuFinal}"`);
  
  try {
    // Fun√ß√£o para limpar e escapar texto para XML de forma segura
    function escapeXmlText(text) {
      if (!text) return '';
      
      // Primeiro decodifica entidades HTML para caracteres normais
      const decoded = decodeHtmlEntities(text);
      
      // Depois escapa apenas os caracteres XML especiais
      return decoded
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
    }

    // Fun√ß√£o para decodificar entidades HTML
    function decodeHtmlEntities(text) {
      if (!text) return '';
      
      const entities = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&apos;': '\'',
        '&nbsp;': ' ',
        '&aacute;': '√°', '&Aacute;': '√Å',
        '&agrave;': '√†', '&Agrave;': '√Ä',
        '&acirc;': '√¢', '&Acirc;': '√Ç',
        '&atilde;': '√£', '&Atilde;': '√É',
        '&auml;': '√§', '&Auml;': '√Ñ',
        '&eacute;': '√©', '&Eacute;': '√â',
        '&egrave;': '√®', '&Egrave;': '√à',
        '&ecirc;': '√™', '&Ecirc;': '√ä',
        '&iacute;': '√≠', '&Iacute;': '√ç',
        '&igrave;': '√¨', '&Igrave;': '√å',
        '&icirc;': '√Æ', '&Icirc;': '√é',
        '&oacute;': '√≥', '&Oacute;': '√ì',
        '&ograve;': '√≤', '&Ograve;': '√í',
        '&ocirc;': '√¥', '&Ocirc;': '√î',
        '&otilde;': '√µ', '&Otilde;': '√ï',
        '&uacute;': '√∫', '&Uacute;': '√ö',
        '&ugrave;': '√π', '&Ugrave;': '√ô',
        '&ucirc;': '√ª', '&Ucirc;': '√õ',
        '&ccedil;': '√ß', '&Ccedil;': '√á'
      };
      
      return text.replace(/&[a-zA-Z]+;/g, (entity) => {
        return entities[entity] || entity;
      });
    }

    // Fun√ß√£o para retornar CSS com fontes embutidas (j√° carregadas na inicializa√ß√£o)
    function getEmbeddedFontsCss() {
      return EMBEDDED_FONTS_CSS;
    }

    // Definir cores por editoria EXATAS do sistema principal
    const editorialColors = {
      'pol√≠cia': '#dc2626',          // üî¥ POL√çCIA: Vermelho
      'pol√≠tica': '#2563eb',         // üîµ POL√çTICA: Azul
      'esporte': '#16a34a',          // üü¢ ESPORTE: Verde
      'entretenimento': '#9333ea',   // üíú ENTRETENIMENTO: Roxo
      'geral': '#ea580c',            // üü† GERAL: Laranja
      'default': '#ea580c'           // laranja padr√£o (geral)
    };

    // Usar cor baseada na categoria fornecida com fallback seguro
    const categoriaParaCor = categoria || 'geral';
    const barColor = editorialColors[categoriaParaCor] || editorialColors['default'];
    
    // Definir dimens√µes baseadas no tipo
    const dimensions = type === 'story' ? { width: 1080, height: 1920 } : { width: 1080, height: 1350 };
    
    // 1. Redimensionar imagem para as dimens√µes corretas
    const resizedImage = await sharp(imagePath)
      .resize(dimensions.width, dimensions.height, { fit: 'cover' })
      .toBuffer();

    // 2. Ler o template overlay correto
    const overlayFile = type === 'story' ? 'overlaystory.png' : 'overlay.png';
    const overlayPath = path.join(__dirname, 'templates', overlayFile);
    console.log(`üñºÔ∏è Carregando template: ${overlayPath}`);
    
    // Verificar se o arquivo existe
    try {
      await fs.access(overlayPath);
      console.log(`‚úÖ Arquivo overlay encontrado`);
    } catch (err) {
      console.error(`‚ùå Arquivo overlay n√£o encontrado: ${overlayPath}`);
      throw new Error(`Template overlay n√£o encontrado: ${overlayFile}`);
    }
    
    const overlayBuffer = await fs.readFile(overlayPath);

    // 3. Fun√ß√£o inteligente para destacar palavras importantes EXATAMENTE IGUAL
    const findKeywords = (text) => {
      console.log(`üîç Analisando t√≠tulo: "${text}"`);
      const words = text.split(' ');
      const stopWords = ['de', 'da', 'do', 'em', 'na', 'no', 'com', 'para', 'por', 'a', 'o', 'e', 'que', 'um', 'uma', 'se', 'foi', 'ser'];
      
      // Crit√©rios para identificar palavras importantes (com suporte a acentos)
      const isProperNoun = (word) => /^[A-Z√Å√Ä√Ç√É√â√ä√ç√ì√î√ï√ö√á]/.test(word) && word.length > 2;
      const isLocation = (word) => {
        const locations = ['Teresina', 'Piau√≠', 'Brasil', 'Bras√≠lia', 'Pedro II', 'Parna√≠ba', 'Picos', 'Regional', 'Nacional', 'Estadual', 'Municipal'];
        return locations.some(loc => word.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').includes(loc.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '')));
      };
      const isNumber = (word) => /\d+/.test(word) || /milh√£o|milh√µes|mil|bilh√£o|bilh√µes/.test(word.toLowerCase()) || /^[IVX]+$/.test(word);
      const isActionVerb = (word) => {
        const verbs = ['vence', 'ganha', 'perde', 'conquista', 'anuncia', 'revela', 'inicia', 'termina', 'aprova', 'rejeita', 'inaugura', 'investe', 'cria'];
        return verbs.some(verb => word.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').includes(verb));
      };
      const isImportantNoun = (word) => {
        const nouns = ['campeonato', 'governo', 'prefeitura', 'empresa', 'projeto', 'investimento', 'hospital', 'escola', 'universidade', 'festival', 'feira', 'educa√ß√£o', 'sa√∫de', 'esta√ß√£o'];
        return nouns.some(noun => word.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').includes(noun.normalize('NFD').replace(/[\u0300-\u036f]/g, '')));
      };
      
      const isRomanNumeral = (word) => /^[IVX]+$/.test(word);
      
      const isCompositeEntity = (words, startIndex) => {
        if (startIndex < words.length - 1 && 
            words[startIndex].toLowerCase() === 'pedro' && 
            words[startIndex + 1].toLowerCase() === 'ii') {
          return 2;
        }
        return 0;
      };
      
      const maxHighlightWords = Math.max(2, Math.floor(words.length * 0.3));
      console.log(`üìè T√≠tulo tem ${words.length} palavras. M√°ximo destaque: ${maxHighlightWords} palavras (30%)`);
      
      let bestStart = -1;
      let bestLength = 0;
      let bestScore = 0;
      
      // Procurar sequ√™ncias cont√≠nuas respeitando o limite de propor√ß√£o
      for (let start = 0; start < words.length; start++) {
        for (let length = 2; length <= Math.min(maxHighlightWords, words.length - start); length++) {
          const sequence = words.slice(start, start + length);
          let score = 0;
          let validSequence = true;
          
          let entityBonus = 0;
          for (let i = 0; i < sequence.length; i++) {
            const entitySize = isCompositeEntity(sequence, i);
            if (entitySize > 0) {
              entityBonus += 5;
              console.log(`üèõÔ∏è Entidade composta detectada: "${sequence.slice(i, i + entitySize).join(' ')}"`);
            }
          }
          
          for (let i = 0; i < sequence.length; i++) {
            const word = sequence[i];
            
            if (stopWords.includes(word.toLowerCase())) {
              if (i === 0 || i === sequence.length - 1) {
                console.log(`‚ö†Ô∏è Sequ√™ncia "${sequence.join(' ')}" invalidada por stop word "${word}" na posi√ß√£o ${i === 0 ? 'in√≠cio' : 'fim'}`);
                validSequence = false;
                break;
              }
              console.log(`‚úÖ Stop word "${word}" aceita no meio da sequ√™ncia "${sequence.join(' ')}"`);
              continue;
            }
            
            let wordScore = 0;
            if (isProperNoun(word)) wordScore += 4;
            if (isLocation(word)) wordScore += 3;
            if (isNumber(word)) wordScore += 3;
            if (isActionVerb(word)) wordScore += 2;
            if (isImportantNoun(word)) wordScore += 3;
            if (isRomanNumeral(word)) wordScore += 4;
            
            if (wordScore === 0 && word.length < 4 && !isRomanNumeral(word)) {
              console.log(`‚ö†Ô∏è Sequ√™ncia "${sequence.join(' ')}" invalidada por palavra irrelevante "${word}" (score: ${wordScore}, length: ${word.length})`);
              validSequence = false;
              break;
            }
            
            score += wordScore;
          }
          
          score += entityBonus;
          
          const sequenceText = sequence.join(' ').toLowerCase();
          if (sequenceText.includes('pedro ii')) {
            score += 8;
            console.log(`üéØ Bonus "Pedro II" aplicado para: "${sequence.join(' ')}"`);
          }
          
          if (start === 0 && sequenceText.includes('pedro ii') && length <= 4) {
            score += 5;
            console.log(`üëë Bonus protagonista inicial aplicado para: "${sequence.join(' ')}"`);
          }
          
          if (validSequence && length >= 2) {
            const hasProperNoun = sequence.some(isProperNoun);
            const hasAction = sequence.some(word => isActionVerb(word) || isImportantNoun(word));
            if (hasProperNoun && hasAction) score += 3;
          }
          
          if (validSequence && start <= 1) score += 1;
          
          if (validSequence) {
            console.log(`üìä Sequ√™ncia "${sequence.join(' ')}" (pos ${start}, len ${length}): score ${score} ${entityBonus > 0 ? `(+${entityBonus} entidade)` : ''}`);
          }
          
          if (validSequence && score > bestScore) {
            bestStart = start;
            bestLength = length;
            bestScore = score;
          }
        }
      }
      
      // Fallback
      if (bestStart === -1) {
        for (let i = 0; i < words.length - 1; i++) {
          if (!stopWords.includes(words[i].toLowerCase()) && 
              !stopWords.includes(words[i + 1].toLowerCase()) &&
              words[i].length > 2 && words[i + 1].length > 2) {
            bestStart = i;
            bestLength = 2;
            console.log(`üîÑ Fallback: destacando "${words[i]} ${words[i + 1]}"`);
            break;
          }
        }
      }
      
      if (bestStart >= 0) {
        const selectedSequence = words.slice(bestStart, bestStart + bestLength).join(' ');
        console.log(`‚úÖ DESTAQUE FINAL: "${selectedSequence}" (posi√ß√£o ${bestStart}, ${bestLength} palavras)`);
      }
      
      return { boldStart: bestStart, boldLength: bestLength };
    };

  // N√£o truncar o t√≠tulo antes; deixar o algoritmo de quebra distribuir em at√© 3 linhas
  const adaptedTitle = title;
  const titleWords = adaptedTitle.split(' ');
  // Determinar destaque: usar personalizado ou autom√°tico
  let boldStart, boldLength;
  
  if (destaquePersonalizado) {
    // Verificar se √© o novo formato com √≠ndices ou o antigo formato de texto
    if (typeof destaquePersonalizado === 'object' && 'inicio' in destaquePersonalizado && 'fim' in destaquePersonalizado) {
      // Novo formato: usar √≠ndices diretos
      console.log(`üéØ Usando destaque personalizado por √≠ndices: ${destaquePersonalizado.inicio} a ${destaquePersonalizado.fim}`);
      boldStart = Math.max(0, destaquePersonalizado.inicio);
      boldLength = Math.max(1, destaquePersonalizado.fim - destaquePersonalizado.inicio + 1);
      console.log(`‚úÖ Destaque por √≠ndice: posi√ß√£o ${boldStart}, ${boldLength} palavra(s)`);
    } else {
      // Formato antigo: buscar texto no t√≠tulo
      console.log(`üéØ Usando destaque personalizado por texto: "${destaquePersonalizado}"`);
      const titleLower = adaptedTitle.toLowerCase();
      const destaqueLower = destaquePersonalizado.toLowerCase();
      const index = titleLower.indexOf(destaqueLower);
      
      if (index !== -1) {
        // Calcular posi√ß√£o em palavras
        const wordsBeforeDestaque = adaptedTitle.substring(0, index).trim().split(' ').filter(w => w.length > 0);
        const palavrasDestaque = destaquePersonalizado.split(' ').filter(w => w.length > 0);
        boldStart = wordsBeforeDestaque.length;
        boldLength = palavrasDestaque.length;
        console.log(`‚úÖ Destaque encontrado: posi√ß√£o ${boldStart}, ${boldLength} palavra(s)`);
      } else {
        console.log(`‚ö†Ô∏è Destaque "${destaquePersonalizado}" n√£o encontrado no t√≠tulo, usando autom√°tico`);
        const result = findKeywords(adaptedTitle);
        boldStart = result.boldStart;
        boldLength = result.boldLength;
      }
    }
  } else {
    // Usar destaque autom√°tico
    const result = findKeywords(adaptedTitle);
    boldStart = result.boldStart;
    boldLength = result.boldLength;
  }
    
    // Usar quebra por largura calculada (respeitando margens e evitando linhas com 1 palavra)
    const maxLines = 3;
    const FONT_SIZE = 76;
    const CHAR_WIDTH_NORMAL = 0.58; // heur√≠stica
    const CHAR_WIDTH_BOLD = 0.62;   // heur√≠stica
    const SPACE_WIDTH = 0.32 * FONT_SIZE;
    const titleMarginLeft = 60;
    const marginRight = 60;
    const titleMaxWidth = dimensions.width - (titleMarginLeft + marginRight);

    function estimateWordWidth(word, isBold) {
      const factor = isBold ? CHAR_WIDTH_BOLD : CHAR_WIDTH_NORMAL;
      return word.length * FONT_SIZE * factor;
    }

  function wrapWordsToWidth(wordsArr, boldStart, boldLength, maxWidth, maxLines) {
      const built = [];
      let line = [];
      let width = 0;
      for (let i = 0; i < wordsArr.length; i++) {
        const w = wordsArr[i];
        const isBold = i >= boldStart && i < boldStart + boldLength;
        const wWidth = estimateWordWidth(w, isBold);
        const extraSpace = line.length > 0 ? SPACE_WIDTH : 0;
        if (width + extraSpace + wWidth <= maxWidth || line.length === 0) {
          line.push({ text: w, isBold });
          width += extraSpace + wWidth;
        } else {
          built.push(line);
          if (built.length >= maxLines) break;
          line = [{ text: w, isBold }];
          width = wWidth;
        }
      }
      if (line.length && built.length < maxLines) built.push(line);

      function lineWidth(arr) {
        let total = 0;
        for (let i = 0; i < arr.length; i++) {
          const ww = estimateWordWidth(arr[i].text, arr[i].isBold);
          total += ww + (i > 0 ? SPACE_WIDTH : 0);
        }
        return total;
      }

      // evitar linhas com 1 palavra (vi√∫vas) sempre que poss√≠vel
      for (let i = 0; i < built.length; i++) {
        if (built[i].length === 1) {
          // tenta puxar do anterior
          const prev = i > 0 ? built[i - 1] : null;
          if (prev && prev.length > 2) {
            const moved = prev.pop();
            if (lineWidth(built[i]) + SPACE_WIDTH + estimateWordWidth(moved.text, moved.isBold) <= maxWidth) {
              built[i].unshift(moved);
            } else {
              prev.push(moved);
            }
          } else if (i + 1 < built.length && built[i + 1].length > 1) {
            // ou puxa da pr√≥xima
            const next = built[i + 1];
            const movedN = next.shift();
            if (movedN) {
              if (lineWidth(built[i]) + (built[i].length ? SPACE_WIDTH : 0) + estimateWordWidth(movedN.text, movedN.isBold) <= maxWidth) {
                built[i].push(movedN);
              } else {
                next.unshift(movedN);
              }
            }
          }
        }
      }

      // clamp por largura
      for (let i = 0; i < built.length; i++) {
        while (lineWidth(built[i]) > maxWidth && built[i].length > 1) {
          const spill = built[i].pop();
          if (i + 1 < built.length) {
            const target = built[i + 1];
            if (lineWidth(target) + (target.length ? SPACE_WIDTH : 0) + estimateWordWidth(spill.text, spill.isBold) <= maxWidth) {
              target.unshift(spill);
            }
          }
        }
      }

      if (built.length > maxLines) built.length = maxLines;
      return built;
    }

    const lines = wrapWordsToWidth(titleWords, boldStart, boldLength, titleMaxWidth, maxLines);

  // Calcular dimens√µes da barra baseado no texto do chap√©u (proporcional)
  const HAT_FONT_SIZE = 33;
  const CHAR_WIDTH_HAT = 0.58; // heur√≠stica m√©dia para Poppins 600
  const hatText = chapeuUpper;
  const hatTextWidth = hatText ? Math.round(hatText.length * HAT_FONT_SIZE * CHAR_WIDTH_HAT) : 0;
  const barWidth = Math.max(hatTextWidth + 40, 200); // padding horizontal ~20px por lado
  const barHeight = 44;
  const barX = 60;
    const barY = type === 'story' ? 950 : 878;
    
    const textX = barX + (barWidth / 2);
    
  const titleStartY = type === 'story' ? 1120 : 1030; // manter baseline do template
  // titleMarginLeft=60 e titleMaxWidth=largura-120 j√° definidos acima

    // 4. Criar SVG com o texto (t√≠tulo e categoria) - FONTE POPPINS EXATA
    const textSvg = `
      <svg width="${dimensions.width}" height="${dimensions.height}" xmlns="http://www.w3.org/2000/svg">
        ${getEmbeddedFontsCss()}
        
        ${chapeuUpper ? `
          <!-- Chap√©u com barra colorida por editoria -->
          <rect x="${barX}" y="${barY}" width="${barWidth}" height="${barHeight}" fill="${barColor}" rx="8"/>
          <text x="${textX}" y="${barY + 29}" fill="white" font-family="Poppins, Arial" font-size="33" font-weight="600" text-anchor="middle">${escapeXmlText(chapeuUpper)}</text>
        ` : ''}
        
        <!-- T√≠tulo com m√∫ltiplas linhas -->
        ${lines.map((line, lineIndex) => {
          const y = titleStartY + (lineIndex * 85);
          
          const lineText = line.map((word, index) => {
            const weight = word.isBold ? '800' : '400';
            const spacing = index > 0 ? ' ' : '';
            return `${spacing}<tspan font-weight="${weight}">${escapeXmlText(word.text)}</tspan>`;
          }).join('');
          
          return `<text x="${titleMarginLeft}" y="${y}" fill="white" font-family="Poppins, Arial" font-size="76">${lineText}</text>`;
        }).join('')}
      </svg>
    `;

    // 5. Compor as camadas: imagem -> overlay -> texto
    const finalImage = await sharp(resizedImage)
      .composite([
        {
          input: overlayBuffer,
          top: 0,
          left: 0
        },
        {
          input: Buffer.from(textSvg),
          top: 0,
          left: 0
        }
      ])
      .png({ quality: 90 })
      .toBuffer();

    console.log('‚úÖ Card gerado com sucesso');
    return finalImage;
    
  } catch (error) {
    console.error('‚ùå Erro ao gerar card:', error);
    throw error;
  }
}

// Fun√ß√£o para publicar no Instagram
async function publishToInstagram(imageBuffer, caption) {
  console.log('üì§ Publicando no Instagram...');
  
  try {
    // Validar URL p√∫blica
    if (!INSTAGRAM_CONFIG.PUBLIC_BASE_URL) {
      throw new Error('PUBLIC_BASE_URL n√£o configurada. Defina uma URL p√∫blica acess√≠vel (ex.: https://seu-dominio.com) para a Meta baixar as imagens.');
    }

    // 1. Salvar imagem em pasta p√∫blica
    const filename = `post_${Date.now()}.png`;
    const publicDir = path.join(__dirname, 'public', 'uploads');
    await fs.ensureDir(publicDir);
    const filepath = path.join(publicDir, filename);
    await fs.writeFile(filepath, imageBuffer);

    // 2. Montar URL p√∫blica (acess√≠vel pela Meta)
    const imageUrl = `${INSTAGRAM_CONFIG.PUBLIC_BASE_URL.replace(/\/$/, '')}/uploads/${filename}`;
    console.log('üñºÔ∏è URL p√∫blica da imagem:', imageUrl);

    // 3. Criar container de m√≠dia
    const createMediaUrl = `${INSTAGRAM_CONFIG.GRAPH_API_URL}/${INSTAGRAM_CONFIG.BUSINESS_ID}/media`;
    
    const mediaResponse = await makeHttpsRequest(createMediaUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        image_url: imageUrl,
        caption: caption,
        access_token: INSTAGRAM_CONFIG.ACCESS_TOKEN
      })
    });

    const mediaResult = await mediaResponse.json();
    console.log('üì± Resposta do container:', mediaResult);

    if (!mediaResponse.ok || mediaResult.error) {
      throw new Error(mediaResult.error?.message || 'Erro ao criar container');
    }

    const creationId = mediaResult.id;
    console.log('‚úÖ Container criado:', creationId);

  // 4. Aguardar processamento
    await new Promise(resolve => setTimeout(resolve, 3000));

  // 5. Publicar m√≠dia
    const publishUrl = `${INSTAGRAM_CONFIG.GRAPH_API_URL}/${INSTAGRAM_CONFIG.BUSINESS_ID}/media_publish`;
    
    const publishResponse = await makeHttpsRequest(publishUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        creation_id: creationId,
        access_token: INSTAGRAM_CONFIG.ACCESS_TOKEN
      })
    });

    const publishResult = await publishResponse.json();
    console.log('üì± Resposta da publica√ß√£o:', publishResult);

    if (!publishResponse.ok || publishResult.error) {
      throw new Error(publishResult.error?.message || 'Erro ao publicar');
    }

  // 6. Limpar arquivo tempor√°rio (opcional)
    setTimeout(async () => {
      try {
    await fs.unlink(filepath).catch(() => {});
        console.log('üóëÔ∏è Arquivo tempor√°rio removido');
      } catch (err) {
        console.log('‚ö†Ô∏è Erro ao remover arquivo tempor√°rio:', err.message);
      }
    }, 5 * 60 * 1000);

    return {
      success: true,
      postId: publishResult.id,
      mediaId: creationId
    };

  } catch (error) {
    console.error('‚ùå Erro na publica√ß√£o:', error);
    throw error;
  }
}

// ROTAS DA API

// P√°gina inicial (interface web)
app.get('/', (req, res) => {
  res.send(`
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R10 Instagram Publisher</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .logo {
            color: #e74c3c;
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }
        input[type="file"] {
            padding: 8px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        .btn {
            background: #e74c3c;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        .btn:hover {
            background: #c0392b;
        }
        .preview {
            margin-top: 20px;
            text-align: center;
            display: none;
        }
        .preview img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            display: none;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .loading {
            text-align: center;
            display: none;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #e74c3c;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
  .logo img { height: 80px; }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo"><img src="${R10_LOGO_DATAURL || '/r10post.png'}" alt="R10 POST"></div>
            <h2>Instagram Publisher</h2>
            <p>Gera√ß√£o e Publica√ß√£o Autom√°tica de Cards</p>
        </div>

        <form id="publishForm" enctype="multipart/form-data">
            <div class="form-group">
                <label for="newsUrl">Link da Mat√©ria (Extra√ß√£o Autom√°tica)</label>
                <div style="display: flex; gap: 10px;">
                    <input type="url" id="newsUrl" name="newsUrl" placeholder="https://r10piaui.com/noticias/..." style="flex: 1;">
                    <button type="button" class="btn" onclick="extractFromUrl()" style="width: auto; padding: 12px 20px; background: #3498db;">üîó Extrair</button>
                </div>
                <small style="color: #666; margin-top: 5px; display: block;">Cole o link da mat√©ria para preencher automaticamente t√≠tulo, categoria e imagem</small>
            </div>

            <div style="border-top: 1px solid #ddd; margin: 20px 0; padding-top: 20px;">
                <h3 style="color: #666; margin-bottom: 15px;">OU preencha manualmente:</h3>
            </div>

            <div class="form-group">
                <label for="title">T√≠tulo da Mat√©ria *</label>
                <textarea id="title" name="title" placeholder="Digite o t√≠tulo da mat√©ria..." required></textarea>
            </div>
      <div class="form-group" style="margin-top: -10px;">
        <label style="display:flex; align-items:center; gap:8px; font-weight: normal; color:#333;">
          <input type="checkbox" id="useManualTitle" name="useManualTitle" value="1">
          Usar exatamente este t√≠tulo no card (sem IA)
        </label>
        <small style="color:#666;">A legenda sempre usa o t√≠tulo completo acima.</small>
      </div>

            <div class="form-group">
                <label for="customChapeu">Chap√©u Personalizado (Opcional)</label>
                <input type="text" id="customChapeu" name="customChapeu" placeholder="Ex: DESTAQUE, URGENTE, EXCLUSIVO..." maxlength="15">
                <small style="color: #666; margin-top: 5px; display: block;">Se n√£o preenchido, ser√° gerado automaticamente pela IA</small>
            </div>

            <div class="form-group">
                <label for="highlightText">Texto em Destaque (Opcional)</label>
                <input type="text" id="highlightText" name="highlightText" placeholder="Palavras espec√≠ficas para destacar em negrito...">
                <small style="color: #666; margin-top: 5px; display: block;">Se n√£o preenchido, a IA escolher√° automaticamente as palavras-chave</small>
            </div>

            <div class="form-group">
                <label for="image">Imagem do Card *</label>
                <input type="file" id="image" name="image" accept="image/*" required>
            </div>

            <div class="form-group">
                <label for="url">Link da Mat√©ria</label>
                <input type="url" id="url" name="url" placeholder="https://www.r10piaui.com/materia/...">
            </div>

            <button type="button" class="btn" onclick="generatePreview()">üé® Gerar Preview</button>
            <button type="button" class="btn" onclick="publishPost()" style="background: #27ae60;">üì§ Publicar no Instagram</button>
        </form>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processando...</p>
        </div>

        <div class="preview" id="preview">
            <h3>Preview do Card</h3>
            <img id="previewImage" src="" alt="Preview">
            <div id="previewCaption" style="margin-top: 15px; text-align: left; background: #f8f9fa; padding: 15px; border-radius: 5px;"></div>
        </div>

        <div class="result" id="result"></div>
    </div>

    <script>
        let currentCardData = null;
        let extractedImageUrl = null;

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('result').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function showResult(message, isError = false) {
            const result = document.getElementById('result');
            result.className = 'result ' + (isError ? 'error' : 'success');
            result.innerHTML = message;
            result.style.display = 'block';
        }

        async function extractFromUrl() {
            const urlInput = document.getElementById('newsUrl');
            const url = urlInput.value.trim();
            
            if (!url) {
                showResult('‚ùå Digite uma URL para extrair os dados', true);
                return;
            }

            showLoading();

            try {
                const response = await fetch('/api/extract-url', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ url })
                });

                const result = await response.json();
                
                if (result.success) {
                    const data = result.data;
                    
                    // Preencher campos automaticamente
                    document.getElementById('title').value = data.title;
                    document.getElementById('category').value = data.category || '';
                    document.getElementById('url').value = data.originalUrl;
                    
                    // Armazenar URL da imagem extra√≠da
                    extractedImageUrl = data.imageUrl;
                    
                    // Mostrar resultado
                    let message = '‚úÖ Dados extra√≠dos com sucesso!<br>';
                    message += '<strong>T√≠tulo:</strong> ' + data.title.substring(0, 100);
                    if (data.title.length > 100) message += '...';
                    message += '<br>';
                    if (data.imageUrl) {
                        message += '<strong>Imagem:</strong> Encontrada automaticamente<br>';
                        // Ocultar campo de upload manual j√° que temos imagem
                        document.querySelector('label[for="image"]').innerHTML = 'Imagem do Card (Opcional - j√° extra√≠da automaticamente)';
                        document.getElementById('image').required = false;
                    } else {
                        message += '<strong>Imagem:</strong> N√£o encontrada - voc√™ precisa fazer upload manual<br>';
                    }
                    message += '<br>Agora clique em "üé® Gerar Preview" para ver o resultado!';
                    
                    showResult(message);
                } else {
                    showResult('‚ùå Erro ao extrair dados: ' + result.error, true);
                }
            } catch (error) {
                showResult('‚ùå Erro de conex√£o: ' + error.message, true);
            }

            hideLoading();
        }

        async function generatePreview() {
            const formData = new FormData(document.getElementById('publishForm'));
            
            // Se temos uma imagem extra√≠da da URL, usar ela
            if (extractedImageUrl && !formData.get('image').size) {
                formData.append('extractedImageUrl', extractedImageUrl);
            }
      // Garantir inclus√£o expl√≠cita da flag de t√≠tulo manual
      const useManual = document.getElementById('useManualTitle').checked;
      if (useManual && !formData.get('useManualTitle')) {
        formData.append('useManualTitle', '1');
      }
            
            if (!formData.get('title')) {
                showResult('‚ùå Preencha o t√≠tulo da mat√©ria', true);
                return;
            }

            if (!formData.get('image').size && !extractedImageUrl) {
                showResult('‚ùå Selecione uma imagem ou extraia de uma URL', true);
                return;
            }

            showLoading();

            try {
                const response = await fetch('/api/generate-card', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
        if (result.success) {
                    currentCardData = result;
                    document.getElementById('previewImage').src = 'data:image/png;base64,' + result.cardImage;
                    document.getElementById('previewCaption').innerHTML = '<strong>Legenda:</strong><br><br>' + result.caption.replace(/\\n/g, '<br>');
                    document.getElementById('preview').style.display = 'block';
          showResult('‚úÖ Card gerado com sucesso! Confira o preview acima.<br>‚ÑπÔ∏è Ao publicar, incluiremos automaticamente a imagem 2 (publicidade fixa).');
                } else {
                    showResult('‚ùå Erro ao gerar card: ' + result.error, true);
                }
            } catch (error) {
                showResult('‚ùå Erro de conex√£o: ' + error.message, true);
            }

            hideLoading();
        }

        async function publishPost() {
            if (!currentCardData) {
                showResult('‚ùå Gere o preview primeiro antes de publicar', true);
                return;
            }

            if (!confirm('Tem certeza que deseja publicar este post no Instagram?')) {
                return;
            }

            showLoading();

            try {
                const response = await fetch('/api/publish-instagram', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(currentCardData)
                });

                const result = await response.json();
                
                if (result.success) {
                    showResult('üéâ Post publicado com sucesso no Instagram!<br>ID do Post: ' + result.postId);
                    currentCardData = null;
                    document.getElementById('preview').style.display = 'none';
                    document.getElementById('publishForm').reset();
                } else {
                    showResult('‚ùå Erro ao publicar: ' + result.error, true);
                }
            } catch (error) {
                showResult('‚ùå Erro de conex√£o: ' + error.message, true);
            }

            hideLoading();
        }

        // UX: se o usu√°rio editar o t√≠tulo manualmente, marcar a flag "usar t√≠tulo manual"
        (function() {
          const titleEl = document.getElementById('title');
          const manualChk = document.getElementById('useManualTitle');
          if (titleEl && manualChk) {
            titleEl.addEventListener('input', () => {
              if (!manualChk.checked) manualChk.checked = true;
            });
          }
        })();

        // UX: chap√©u sempre em caixa alta na edi√ß√£o manual
        (function() {
          const chEl = document.getElementById('customChapeu');
          if (chEl) {
            chEl.addEventListener('input', () => {
              const start = chEl.selectionStart; const end = chEl.selectionEnd;
              chEl.value = (chEl.value || '').toUpperCase();
              // restaurar caret
              try { chEl.setSelectionRange(start, end); } catch(e) {}
            });
            chEl.addEventListener('blur', () => { chEl.value = (chEl.value || '').toUpperCase(); });
          }
        })();
    </script>
</body>
</html>
  `);
});

// API para extrair dados de uma URL
app.post('/api/extract-url', async (req, res) => {
  console.log('üîó Requisi√ß√£o para extrair dados de URL');
  
  try {
    const { url } = req.body;

    if (!url) {
      return res.json({ 
        success: false, 
        error: 'URL √© obrigat√≥ria' 
      });
    }

    // Validar se √© uma URL v√°lida
    try {
      new URL(url);
    } catch {
      return res.json({ 
        success: false, 
        error: 'URL inv√°lida' 
      });
    }

    console.log(`üîç Extraindo dados de: ${url}`);
    const extractedData = await extractDataFromUrl(url);

    res.json({
      success: true,
      data: extractedData
    });

  } catch (error) {
    console.error('‚ùå Erro ao extrair dados:', error);
    res.json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API para processar URL (extrai dados, gera t√≠tulo/chap√©u/legenda e o card)
app.post('/api/process-url', async (req, res) => {
  console.log('üß† Requisi√ß√£o para processar URL (end-to-end)');
  console.log('üì• Body recebido:', req.body);

  try {
  const { url, categoria, destaquePersonalizado } = req.body;
  const chapeuPersonalizado = req.body.chapeuPersonalizado || req.body.customChapeu;
    const newsUrl = url || req.body.newsUrl; // Suporte para ambos os formatos

    if (!newsUrl) {
      console.error('‚ùå URL n√£o fornecida');
      return res.json({
        success: false,
        error: 'URL √© obrigat√≥ria'
      });
    }

    if (!categoria) {
      console.error('‚ùå Categoria n√£o fornecida');
      return res.json({
        success: false,
        error: 'Categoria √© obrigat√≥ria'
      });
    }

    // Validar URL
    try {
      new URL(newsUrl);
    } catch (urlError) {
      console.error('‚ùå URL inv√°lida:', newsUrl);
      return res.json({ success: false, error: 'URL inv√°lida' });
    }

    console.log(`üîç Extraindo dados iniciais de: ${newsUrl}`);
    const extracted = await extractDataFromUrl(newsUrl);

    console.log('üìã Resultado da extra√ß√£o:', {
      hasTitle: !!extracted?.title,
      hasImage: !!extracted?.imageUrl,
      extracted: extracted
    });

    if (!extracted || !extracted.title) {
      console.error('‚ùå T√≠tulo n√£o extra√≠do');
      return res.json({ success: false, error: 'N√£o foi poss√≠vel extrair o t√≠tulo da p√°gina' });
    }

    if (!extracted.imageUrl) {
      console.error('‚ùå Imagem n√£o encontrada');
      return res.json({ success: false, error: 'N√£o foi poss√≠vel localizar a imagem principal da not√≠cia' });
    }

    const originalTitle = extracted.title;

    // Decodificar entidades HTML no t√≠tulo para uso na legenda
    function decodeHtmlEntitiesGlobal(text) {
      const entities = {
        '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&apos;': '\'', '&nbsp;': ' ',
        '&aacute;': '√°', '&Aacute;': '√Å', '&agrave;': '√†', '&Agrave;': '√Ä',
        '&acirc;': '√¢', '&Acirc;': '√Ç', '&atilde;': '√£', '&Atilde;': '√É',
        '&auml;': '√§', '&Auml;': '√Ñ', '&eacute;': '√©', '&Eacute;': '√â',
        '&egrave;': '√®', '&Egrave;': '√à', '&ecirc;': '√™', '&Ecirc;': '√ä',
        '&iacute;': '√≠', '&Iacute;': '√ç', '&igrave;': '√¨', '&Igrave;': '√å',
        '&icirc;': '√Æ', '&Icirc;': '√é', '&oacute;': '√≥', '&Oacute;': '√ì',
        '&ograve;': '√≤', '&Ograve;': '√í', '&ocirc;': '√¥', '&Ocirc;': '√î',
        '&otilde;': '√µ', '&Otilde;': '√ï', '&uacute;': '√∫', '&Uacute;': '√ö',
        '&ugrave;': '√π', '&Ugrave;': '√ô', '&ucirc;': '√ª', '&Ucirc;': '√õ',
        '&ccedil;': '√ß', '&Ccedil;': '√á'
      };
      return text.replace(/&[a-zA-Z]+;/g, (entity) => entities[entity] || entity);
    }

  const decodedTitle = decodeHtmlEntitiesGlobal(originalTitle);

  // Otimizar t√≠tulo e gerar chap√©u/legenda
  const optimizedTitle = await optimizeTitle(originalTitle, extracted.description);
  // Usar chap√©u personalizado ou gerar automaticamente SEMPRE EM CAIXA ALTA
  const chapeu = (chapeuPersonalizado ? String(chapeuPersonalizado) : await generateChapeu(optimizedTitle)).toUpperCase();
  console.log(`üè∑Ô∏è Chap√©u definido: "${chapeu}" ${chapeuPersonalizado ? '(personalizado)' : '(autom√°tico)'}`);
  // Legenda deve usar o T√çTULO COMPLETO DECODIFICADO (sem entidades HTML)
  const caption = await generateCaption(decodedTitle, chapeu.toUpperCase());

    // Baixar a imagem para arquivo tempor√°rio
    let tempImagePath;
    try {
      console.log('üì• Baixando imagem para gerar o card:', extracted.imageUrl);
      const imageResponse = await makeHttpsRequest(extracted.imageUrl);
      if (!imageResponse.ok) {
        throw new Error(`Falha ao baixar a imagem (status ${imageResponse.status})`);
      }
      const imageBuffer = await imageResponse.buffer();
      const filename = `extracted_${Date.now()}.jpg`;
      tempImagePath = path.join(__dirname, 'uploads', filename);
      await fs.ensureDir(path.dirname(tempImagePath));
      await fs.writeFile(tempImagePath, imageBuffer);
      console.log('‚úÖ Imagem baixada com sucesso');
    } catch (downloadErr) {
      console.error('‚ùå Erro ao baixar imagem:', downloadErr);
      return res.json({ success: false, error: 'Erro ao baixar a imagem da not√≠cia' });
    }

    try {
      // Gerar o card usando o overlay f√≠sico
      const cardBuffer = await generateInstagramCard({
        title: optimizedTitle,
        categoria,
        imagePath: tempImagePath,
        chapeu,
        destaquePersonalizado,
        type: 'card'
      });

      // Limpar arquivo tempor√°rio
      try { await fs.unlink(tempImagePath); } catch {}

      return res.json({
        success: true,
        cardImage: cardBuffer.toString('base64'),
        caption,
        title: optimizedTitle,
        categoria,
        url,
        extractedImageUrl: extracted.imageUrl
      });
    } catch (genErr) {
      console.error('‚ùå Erro ao gerar card a partir da URL:', genErr);
      try { if (tempImagePath) await fs.unlink(tempImagePath); } catch {}
      return res.json({ success: false, error: genErr.message });
    }

  } catch (error) {
    console.error('‚ùå Erro no processamento da URL:', error);
    res.json({ success: false, error: error.message });
  }
});

// API para gerar card (preview)
app.post('/api/generate-card', upload.single('image'), async (req, res) => {
  console.log('üì® Requisi√ß√£o para gerar card recebida');
  
  try {
  const { title, category, url, extractedImageUrl } = req.body;
  const chapeuPersonalizado = req.body.chapeuPersonalizado || req.body.customChapeu;
    let { destaquePersonalizado } = req.body;
    
    // Processar destaquePersonalizado se for string JSON
    if (typeof destaquePersonalizado === 'string' && destaquePersonalizado !== '') {
      try {
        destaquePersonalizado = JSON.parse(destaquePersonalizado);
      } catch (e) {
        console.log('‚ö†Ô∏è destaquePersonalizado n√£o √© JSON v√°lido, usando como texto');
      }
    }
    
    const useManualTitle = req.body.useManualTitle === '1' || req.body.useManualTitle === 'true';
    let imagePath = req.file?.path;

    if (!title) {
      return res.json({ 
        success: false, 
        error: 'T√≠tulo √© obrigat√≥rio' 
      });
    }

    // Se n√£o temos arquivo de upload mas temos URL extra√≠da, baixar a imagem
    if (!imagePath && extractedImageUrl) {
      console.log('üì• Baixando imagem da URL extra√≠da:', extractedImageUrl);
      try {
        const imageResponse = await makeHttpsRequest(extractedImageUrl);
        if (imageResponse.ok) {
          const imageBuffer = await imageResponse.buffer();
          const filename = `extracted_${Date.now()}.jpg`;
          imagePath = path.join(__dirname, 'uploads', filename);
          await fs.ensureDir(path.dirname(imagePath));
          await fs.writeFile(imagePath, imageBuffer);
          console.log('‚úÖ Imagem baixada com sucesso');
        }
      } catch (downloadError) {
        console.error('‚ùå Erro ao baixar imagem:', downloadError);
        return res.json({ 
          success: false, 
          error: 'Erro ao baixar imagem da URL: ' + downloadError.message 
        });
      }
    }

    if (!imagePath) {
      return res.json({ 
        success: false, 
        error: 'Imagem √© obrigat√≥ria (upload ou URL)' 
      });
    }

    console.log(`üìù Processando: "${title}" (useManualTitle=${useManualTitle})`);

  // Definir t√≠tulo do card: manual (sem IA) ou otimizado via IA
    let optimizedTitle;
    if (useManualTitle) {
      // Usar exatamente o que o usu√°rio digitou (apenas trim), sem IA e sem ajustes locais
      optimizedTitle = (title || '').toString().trim();
    } else {
      optimizedTitle = await optimizeTitle(title, undefined);
    }
    
    // Gerar chap√©u complementar - usar personalizado se fornecido
  const chapeu = (chapeuPersonalizado ? String(chapeuPersonalizado) : await generateChapeu(optimizedTitle)).toUpperCase();
    console.log(`üè∑Ô∏è Chap√©u definido: "${chapeu}" ${chapeuPersonalizado ? '(personalizado)' : '(autom√°tico)'}`);
    
  // Decodificar entidades HTML no t√≠tulo para legenda
  function decodeHtmlEntitiesUpload(text) {
    const entities = {
      '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&apos;': '\'', '&nbsp;': ' ',
      '&aacute;': '√°', '&Aacute;': '√Å', '&agrave;': '√†', '&Agrave;': '√Ä',
      '&acirc;': '√¢', '&Acirc;': '√Ç', '&atilde;': '√£', '&Atilde;': '√É',
      '&auml;': '√§', '&Auml;': '√Ñ', '&eacute;': '√©', '&Eacute;': '√â',
      '&egrave;': '√®', '&Egrave;': '√à', '&ecirc;': '√™', '&Ecirc;': '√ä',
      '&iacute;': '√≠', '&Iacute;': '√ç', '&igrave;': '√¨', '&Igrave;': '√å',
      '&icirc;': '√Æ', '&Icirc;': '√é', '&oacute;': '√≥', '&Oacute;': '√ì',
      '&ograve;': '√≤', '&Ograve;': '√í', '&ocirc;': '√¥', '&Ocirc;': '√î',
      '&otilde;': '√µ', '&Otilde;': '√ï', '&uacute;': '√∫', '&Uacute;': '√ö',
      '&ugrave;': '√π', '&Ugrave;': '√ô', '&ucirc;': '√ª', '&Ucirc;': '√õ',
      '&ccedil;': '√ß', '&Ccedil;': '√á'
    };
    return text.replace(/&[a-zA-Z]+;/g, (entity) => entities[entity] || entity);
  }
  
  const titleDecodificado = decodeHtmlEntitiesUpload(title);
  // Legenda deve usar o T√çTULO COMPLETO DECODIFICADO informado (n√£o o otimizado)
  const caption = await generateCaption(titleDecodificado, chapeu.toUpperCase());
    
    // Gerar card
    const cardBuffer = await generateInstagramCard({
      title: optimizedTitle,
      categoria: category,
      imagePath,
      chapeu,
      destaquePersonalizado,
      type: 'card'
    });

    // Remover arquivo de upload/download tempor√°rio
    try {
      await fs.unlink(imagePath);
    } catch (err) {
      console.log('‚ö†Ô∏è Arquivo tempor√°rio j√° foi removido ou n√£o existe');
    }

    res.json({
      success: true,
      cardImage: cardBuffer.toString('base64'),
      caption,
      title: optimizedTitle,
      categoria: category,
      url
    });

  } catch (error) {
    console.error('‚ùå Erro ao gerar card:', error);
    res.json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API para upload da imagem publicit√°ria
app.post('/api/upload-publicity', upload.single('publicity'), async (req, res) => {
  console.log('üì§ Requisi√ß√£o para salvar card publicit√°rio');
  
  try {
    if (!req.file) {
      return res.json({ 
        success: false, 
        error: 'Imagem publicit√°ria √© obrigat√≥ria' 
      });
    }

    // Redimensionar para 1080x1350 e salvar
  await fs.ensureDir(PERSIST_DIR);
  const publicityPath = path.join(PERSIST_DIR, 'publicity-card.jpg');
    const processed = await sharp(req.file.path)
      .resize(1080, 1350, { fit: 'cover', position: 'center' })
      .jpeg({ quality: 92 })
      .toBuffer();
    await fs.writeFile(publicityPath, processed);

    // Converter para base64 (preview)
    const base64Image = processed.toString('base64');

    // Limpar arquivo tempor√°rio
    await fs.unlink(req.file.path);

    console.log('‚úÖ Card publicit√°rio salvo com sucesso');

    res.json({
      success: true,
      publicityImage: base64Image
    });

  } catch (error) {
    console.error('‚ùå Erro ao salvar card publicit√°rio:', error);
    res.json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Helper para obter e verificar caminho persistente da publi
function getPersistedPublicityPath() {
  return path.join(PERSIST_DIR, 'publicity-card.jpg');
}

// API para buscar a imagem publicit√°ria salva (persistente)
app.get('/api/get-publicity', async (req, res) => {
  try {
    const publicityPath = getPersistedPublicityPath();
    const persisted = fs.existsSync(publicityPath);
    // Garante que exista uma publi persistida; se n√£o existir, cria e salva a padr√£o
    const buffer = await getOrCreatePublicityBuffer();
    const base64Image = buffer.toString('base64');
    res.json({ success: true, publicityImage: base64Image, persisted });
  } catch (error) {
    res.json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API para remover a imagem publicit√°ria salva (persistente)
app.delete('/api/delete-publicity', async (req, res) => {
  try {
    const publicityPath = getPersistedPublicityPath();
    if (fs.existsSync(publicityPath)) {
      await fs.unlink(publicityPath);
      return res.json({ success: true, message: 'Publiciade removida' });
    }
    return res.json({ success: false, error: 'Nenhuma publi persistida' });
  } catch (error) {
    return res.json({ success: false, error: error.message });
  }
});

// Fun√ß√£o para publicar carrossel no Instagram
async function publishCarouselToInstagram(images, caption) {
  console.log('üì§ Publicando carrossel no Instagram...');
  
  try {
    if (!INSTAGRAM_CONFIG.PUBLIC_BASE_URL) {
      throw new Error('PUBLIC_BASE_URL n√£o configurada. Defina uma URL p√∫blica acess√≠vel (ex.: https://seu-dominio.com) para a Meta baixar as imagens.');
    }

    // Passo 1: Criar containers para cada imagem
    const mediaIds = [];
    const publicDir = path.join(__dirname, 'public', 'uploads');
    await fs.ensureDir(publicDir);
  const tempFiles = [];

    for (let i = 0; i < images.length; i++) {
      const imageBuffer = images[i];
      console.log(`üì∏ Criando container para imagem ${i + 1}/${images.length}...`);

      // Salvar arquivo p√∫blico
      const filename = `carousel_${Date.now()}_${i + 1}.png`;
  const filepath = path.join(publicDir, filename);
  await fs.writeFile(filepath, imageBuffer);
  tempFiles.push(filepath);

      const imageUrl = `${INSTAGRAM_CONFIG.PUBLIC_BASE_URL.replace(/\/$/, '')}/uploads/${filename}`;

      // Criar container com image_url
      const createUrl = `${INSTAGRAM_CONFIG.GRAPH_API_URL}/${INSTAGRAM_CONFIG.BUSINESS_ID}/media`;
      const containerResponse = await makeHttpsRequest(createUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          image_url: imageUrl,
          is_carousel_item: true,
          access_token: INSTAGRAM_CONFIG.ACCESS_TOKEN
        })
      });

      const containerData = await containerResponse.json();
      console.log(`üìã Container ${i + 1} response:`, containerData);

      if (!containerResponse.ok || containerData.error) {
        // Limpeza imediata dos arquivos criados at√© aqui
        for (const f of tempFiles) { try { await fs.unlink(f); } catch {} }
        throw new Error(`Erro no container ${i + 1}: ${containerData.error?.message || 'Falha ao criar container'}`);
      }

      mediaIds.push(containerData.id);
    }
    
    console.log(`üìã Containers criados:`, mediaIds);
    
    // Passo 2: Criar container do carrossel
    const carouselCreateUrl = `${INSTAGRAM_CONFIG.GRAPH_API_URL}/${INSTAGRAM_CONFIG.BUSINESS_ID}/media`;
    const carouselResponse = await makeHttpsRequest(carouselCreateUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        media_type: 'CAROUSEL',
        children: mediaIds.join(','),
        caption,
        access_token: INSTAGRAM_CONFIG.ACCESS_TOKEN
      })
    });
    const carouselData = await carouselResponse.json();
    console.log('üìã Carousel container response:', carouselData);
    
    if (!carouselResponse.ok || carouselData.error) {
      for (const f of tempFiles) { try { await fs.unlink(f); } catch {} }
      throw new Error(`Erro no carrossel: ${carouselData.error?.message || 'Falha ao criar carrossel'}`);
    }
    
    // Passo 3: Publicar o carrossel
    const publishUrl = `${INSTAGRAM_CONFIG.GRAPH_API_URL}/${INSTAGRAM_CONFIG.BUSINESS_ID}/media_publish`;
    const publishResponse = await makeHttpsRequest(publishUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        creation_id: carouselData.id,
        access_token: INSTAGRAM_CONFIG.ACCESS_TOKEN
      })
    });
    const publishData = await publishResponse.json();
    console.log('üìã Publish response:', publishData);
    
    if (!publishResponse.ok || publishData.error) {
      for (const f of tempFiles) { try { await fs.unlink(f); } catch {} }
      throw new Error(`Erro na publica√ß√£o: ${publishData.error?.message || 'Falha ao publicar'}`);
    }

    // Limpeza agendada dos arquivos do carrossel (n√£o persistir cards, apenas publi fixa permanece)
    setTimeout(async () => {
      for (const f of tempFiles) {
        try { await fs.unlink(f); } catch {}
      }
      console.log('üóëÔ∏è Arquivos do carrossel removidos');
    }, 10 * 60 * 1000);
    
    return {
      postId: publishData.id,
      carouselId: carouselData.id,
      mediaIds: mediaIds
    };
    
  } catch (error) {
    console.error('‚ùå Erro ao publicar carrossel:', error);
    throw error;
  }
}

// API para publicar carrossel no Instagram
app.post('/api/publish-carousel', async (req, res) => {
  console.log('üì§ Requisi√ß√£o para publicar carrossel no Instagram');
  
  try {
    const { newsCard, caption } = req.body;

    if (!newsCard || !caption) {
      return res.json({ 
        success: false, 
        error: 'Card da not√≠cia e legenda s√£o obrigat√≥rios' 
      });
    }

    // Converter base64 para buffer da not√≠cia e usar SEMPRE a publi persistida/padr√£o
    const newsBuffer = Buffer.from(newsCard, 'base64');
    const publicityBuffer = await getOrCreatePublicityBuffer();
    
    // Publicar carrossel no Instagram
    const result = await publishCarouselToInstagram([newsBuffer, publicityBuffer], caption);

    res.json({
      success: true,
      postId: result.postId,
      carouselId: result.carouselId,
      mediaIds: result.mediaIds
    });

  } catch (error) {
    console.error('‚ùå Erro ao publicar carrossel:', error);
    res.json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API para publicar no Instagram (mantida para compatibilidade)
app.post('/api/publish-instagram', async (req, res) => {
  console.log('üì§ Requisi√ß√£o para publicar no Instagram');
  
  try {
    const { cardImage, caption } = req.body;

    if (!cardImage || !caption) {
      return res.json({ 
        success: false, 
        error: 'Dados do card s√£o obrigat√≥rios' 
      });
    }

    // Converter base64 para buffer
    const imageBuffer = Buffer.from(cardImage, 'base64');

    // Sempre publicar como carrossel: not√≠cia + PUBLI fixa (persistida ou gerada e gravada)
    const publicityBuffer = await getOrCreatePublicityBuffer();
    const carResult = await publishCarouselToInstagram([imageBuffer, publicityBuffer], caption);
    return res.json({ success: true, postId: carResult.postId, carouselId: carResult.carouselId, mediaIds: carResult.mediaIds, usedCarousel: true });

  } catch (error) {
    console.error('‚ùå Erro ao publicar:', error);
    res.json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Servir fontes como arquivos est√°ticos (backup para Render)
app.use('/fonts', express.static(path.join(__dirname, 'fonts')));

// Iniciar servidor
app.listen(PORT, () => {
  console.log(`üöÄ R10 Instagram Publisher iniciado na porta ${PORT}`);
  console.log(`üåê Acesse: http://localhost:${PORT}`);
  console.log(`üì± Instagram Business ID: ${INSTAGRAM_CONFIG.BUSINESS_ID || 'N√ÉO DEFINIDO'}`);
  console.log(`üîë IG Token configurado? ${INSTAGRAM_CONFIG.ACCESS_TOKEN ? 'Sim' : 'N√£o'}`);
  console.log(`ü§ñ Groq AI configurado? ${GROQ_CONFIG.API_KEY ? 'Sim' : 'N√£o'}`);
  console.log(`üíæ Diret√≥rio persistente da PUBLI: ${PERSIST_DIR}`);
  if (!GROQ_CONFIG.API_KEY) console.log('‚ö†Ô∏è Defina a vari√°vel de ambiente GROQ_API_KEY para habilitar IA.');
  if (!INSTAGRAM_CONFIG.ACCESS_TOKEN) console.log('‚ö†Ô∏è Defina IG_ACCESS_TOKEN para publicar no Instagram.');
  if (!INSTAGRAM_CONFIG.PUBLIC_BASE_URL) console.log('‚ö†Ô∏è Defina PUBLIC_BASE_URL (ex.: https://seu-dominio.com) para permitir a publica√ß√£o (image_url exigido pela Meta).');
});
